# [리팩터링] 1. 첫번째 예시
</br>

- 처음부터 완벽한 설계를 갖추기보다는 개발을 진행하면서 지속적으로 설계한다
- 리팩터링을 마구잡이로 하면 폭망의 구렁텅이로 빠질 수 있다
- 제대로 설계하고 들어가야 함

</br>

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다

</br>

- 예시 코드에서 수정해야 할 부분
  - 청구 내역을 HTML로 출력하는 기능 필요
  - 연극 장르와 공연료 정책이 변경될 수 있음

</br>

> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트를 반드시 자가진단하도록 만든다

</br>

- 리팩터링의 첫 단계 : 리팩터링할 코드 영역에 대한 꼼꼼한 테스트 코드
  - 함수의 반환 값에 맞는 형태의 정답 몇 개 준비
  - 테스트 실행할 단축키 설정
  - 테스트 결과는 인지하기 쉽게 (초록불/빨간불)
  - 실수할 가능성을 크게 줄임
  - 디버깅 시간이 줄어 전체 작업 시간은 오히려 단축됨

</br></br>

## 1.4 statement() 함수 쪼개기

</br>

- 긴 함수 리팩터링 시 부분으로 나눌 수 있는 지점 찾아라
  - → switch 문
    - **한 번 공연**에 대한 **요금** 계산
- 정보가 코드를 분석해서 나온다? → 리팩터링 대상
  - 다음번 코드를 볼 때 다시 분석하지 않아도 코드 스스로 자신이 하는 일이 무엇인지 이야기 해줘야 한다.
  - 여기 switch문은 **amountFor**(**aPerformance**) 정도로 변경

</br>

### 함수 추출하기

- 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는 확인
- 예시 코드에서는 `perf`, `play`, `thisAmount`
- `perf`, `play`는 값을 변경하지 않기 때문에 매개변수로 전달하면 ok
- `thisAmount`는 함수 안에서 값이 바뀌기 때문에 조심
- vscode에서 자동 추출

<img src="https://github.com/smileeunsong/refactoring/assets/111448985/75514ce6-460c-430f-8fe2-f6fefefdd998" width="50%">

</br>

- 코드 수정 후에는 곧바로 테스트해서 실수한 게 없는지 확인
  - 조금씩 변경하고 매번 테스트

</br>

> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

</br>

### 변수 이름 더 명확하게

- `thisAmount` → `result`
  - 저자는 함수의 반환 값에는 항상 result라는 이름을 씀
- 하나 고치고 바로 테스트 - 커밋
- `perf` → `aPerformance`
  - js와 같은 동적 타입 언어를 사용할 때는 타입이 드러나게 작성하면 좋음
  - 매개변수 이름에 접두어로 타입 이름
  - 지금처럼 매개변수의 역할이 뚜렷하지 않을 때는 부정관사(a/an) 붙임

</br>

> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

</br>

### 임시 변수를 질의 함수로 바꾸기

- play 변수 제거
  - play는 개별 공연(aPerformance)에서 얻기 때문에 애초에 매개변수로 전달할 필요 없음
  - 그냥 amountFor() 안에서 다시 계산하면 됨
  - 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해짐

</br>

### 변수 인라인하기

- 임시 변수의 우변을 질의 함수로 바꾸고 해당 변수가 있던 자리에 함수를 직접 넣음

</br>

### 함수 선언 바꾸기

- 추출한 함수를 이용해서 변경 가능한 부분 수정
- 그에 따라 필요없어진 매개변수 삭제

</br>


> 👉 지역 변수를 제거하면 추출 작업 쉬워짐 </br> 추출작업 전에는 항상 지역 변수부터 제거할 것

</br>


### 반복문 쪼개기

- 상위에서 반복문이 돌아가는 것에 의존하고 있다면 한번 더 써서 일단 분리시키기
- 보통 반복문이 중복되는 것이 성능에 악영향을 끼칠까봐 피하지만 이 정도 중복은 성능에 미치는 영향이 미미함
- 성능이 떨어진다고 해도 일단 리팩터링 후, 성능 개선 → 결과적으로 더 깔끔, 더 빠른 코드

</br>

### 문장 슬라이드하기

- 변수 선언(초기화)을 사용되는 곳 앞으로 이동

</br>

### volumeCredits 변수 제거 작업

1. 반복문 쪼개기 : 변수 값을 누적시키는 부분 분리
2. 문장 슬라이드하기 : 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮김
3. 함수 추출하기 : 적립 포인트 계산 부분을 별도 함수로 추출
4. 변수 인라인하기 : volumeCredits 변수 제거

</br>


> 👉 리팩터링 중간에 테스트 실패하고 원인을 바로 찾지 못하면? </br> → 가장 최근 커밋으로 돌아가서 실패한 리팩터링 단계를 더 작게 나눠 다시 시도


</br>



## 1.6 계산 단계와 포맷팅 단계 분리하기

</br>

### 단계 쪼개기

- 첫번째 단계 : statement()에 필요한 데이터를 처리
- 두번째 단계 : 앞서 처리한 결과를 텍스트나 HTML로 표현
- 첫번째 단계에서는 두번째 단계로 전달할 중간 데이터 구조를 생성하는 것

```jsx
statementData.performances = invoice.performances.map(enrichPerformance); // <- 공연 정보를 중간 데이터로 옮김

function enrichPerformance(aPerformance) {
  const result = Object.assign({}, aPerformance); // 얕은 복사 수행
  return result;
}
```
</br>


> 👉 mutable 데이터는 금방 상하기 때문에 데이터를 최대한 immutable처럼 취급하라 (얕은 복사를 한 이유)

</br>

### 함수 옮기기

- 함수를 기능에 따라 구분해서 사용하기 위함
  - renderPlainText() 내에 있던 함수들을 statement()로 이동
  - 기존에 사용하던 곳에는 넘겨주는 데이터에 맞게 변환

</br>

### 반복문을 파이프라인으로 바꾸기

- for문 돌면서 더하던 값을 reduce로 변환

```jsx
// 변경 전
function totalVolumeCredits() {
  let volumeCredits = 0;
  for (let perf of invoice.performances) {
    volumeCredits += volumeCreditsFor(perf);
  }
  return volumeCredits;
}

// 변경 후
function totalVolumeCredits(data) {
  return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
}
```
</br>

> 캠핑자들에게는 “도착했을 때보다 깔끔하게 정돈하고 떠난다”라는 규칙이 있다. 프로그래밍도 마찬가지다. 항시 코드베이스를 작업 시작 전보다 건강하게(healthy) 만들어놓고 떠나야 한다.
</br>

## 1.8 다형성을 활용해 계산 코드 재구성하기
 
</br>

### 작업 목표

- 상속 계층을 구성해서 희극 서브클래스와 비극 서브클래스가 각자의 구체적인 계산 로직을 정의
- 호출하는 쪽에서는 다형성 버전의 공연료 계산 함수를 호출하기만 하면 됨

</br>

### 조건부 로직을 다형성으로 바꾸기

- 상속 계층부터 정의
  - 공연료와 적립 포인트 계산 함수를 담을 클래스 필요
- 새로 만든 클래스에 로직 하나씩 옮기고 호출되는 부분도 수정
- **타입 코드를 서브클래스로 바꾸기**
- 서브 클래스에 메서드를 정의하기만 해도 슈퍼클래스의 조건부 로직이 오버라이드 됨
  - 슈퍼클래스의 케이스에는 에러를 반환하여 서브클래스를 이용하도록 유도
  - 공통되는 부분은 슈퍼클래스에 남겨두고 서브클래스에서 추가 처리
  ```jsx
  class ComedyCalculator extends PerformanceCalculator {
    get volumeCredits() {
      return super.volumeCredits + Math.floor(this.performance.audience / 5);
    }
  }
  ```
- 장르 추가에 따른 유지보수도 매우 쉬워짐

</br>

### 타입 코드를 서브클래스로 바꾸기

- 딱 맞는 서브클래스를 사용하려면 생성자 대신 함수를 호출하도록 바꿔야 함
  - js는 생성자가 서브클래스의 인스턴스를 반환할 수 없기 때문
  - **생성자를 팩터리 함수로 바꾸기**

</br>

## 1.10 마치며

</br>

- 크게 세 단계로 진행했음
  - 원본 함수를 중첩 함수 여러 개로 나눔
  - 단계 쪼개기를 적용해서 계산 코드와 출력 코드를 분리
  - 계산 로직을 다형성으로 표현
- 리팩터링은 대부분 코드가 하는 일을 파악하는 데서 시작
- 좋은 코드를 가늠하는 확실한 방법은 ‘얼마나 수정하기 쉬운가’다
- 다음 사실을 깨닫는다면 효과적인 리팩터링 가능
  - 단계를 잘게 나눠야 더 빠르게 처리 가능
  - 코드는 절대 깨지지 않음
  - 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있음
